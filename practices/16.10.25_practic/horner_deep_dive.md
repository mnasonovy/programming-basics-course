# Алгоритм Горнера: полный разбор для вычисления многочлена и его производной

> Цель — дать *интуитивное* и *практическое* понимание алгоритма Горнера для одновременного вычисления $P(x)$ и $P'(x)$. Здесь: теория, пошаговые примеры для степеней 1 и 2, общий вывод формул, псевдокод, типичные ошибкии тесты.

---

## 1. Постановка задачи

Дан многочлен степени $n$ в **коэффициентной форме** (коэффициенты по возрастанию степеней):

$$
P(x) = a_0 + a_1 x + a_2 x^2 + \dots + a_n x^n,\quad a_n \ne 0.
$$

Требуется для заданного $x$ вычислить **значение многочлена** $P(x)$ и **значение производной** $P'(x)$.

---

## 2. Почему наивный способ плох

Прямой подсчёт через степени $x^k$ приводит к большому числу операций и накоплению ошибок:

$$
P(x) = a_0 + a_1 x + a_2 x^2 + \dots + a_n x^n.
$$

Чтобы посчитать все $x^k$, нужно порядка $\dfrac{n(n+1)}{2}$ умножений (если возводить «с нуля»), плюс сложения. Это медленно и численно нестабильно при больших $|x|$ или сильно отличающихся по масштабу коэффициентах.

---

## 3. Идея Горнера 

Факторизуем $x$ «ступеньками», начиная со старшего коэффициента:

$$
\begin{aligned}
P(x)
&= a_0 + x\!\left(a_1 + x\!\left(a_2 + \dots + x\!\left(a_{n-1} + x a_n\right)\!\dots\!\right)\right) \\
&= \bigl(((a_n x + a_{n-1})x + a_{n-2})x + \dots \bigr) .
\end{aligned}
$$

Теперь на каждом шаге всего **одно умножение и одно сложение**. Итого $n$ умножений и $n$ сложений. Быстро и аккуратно.

---

## 4. Одновременное вычисление $P(x)$ и $P'(x)$

Введём две последовательности $b_k$ и $c_k$ (идём от старших коэффициентов к младшим):

- $b_k$ — «остаток» для $P(x)$ на шаге $k$;
- $c_k$ — «остаток» для $P'(x)$ на шаге $k$.

Стартуем с
$$
b_n = a_n,\qquad c_n = 0.
$$

Дальше для $k = n-1, n-2, \ldots, 0$:
$$
\boxed{
\begin{aligned}
b_k &= a_k + x\, b_{k+1}, \\[4pt]
c_k &= b_{k+1} + x\, c_{k+1}.
\end{aligned}
}
$$

После завершения цикла:
$$
\boxed{P(x) = b_0,\qquad P'(x) = c_0.}
$$

**Почему это верно?**  
Если $P_k(x) = a_k + x\,P_{k+1}(x)$, то по правилу производной $(x f)' = f + x f'$ имеем  
$P'_k(x) = P_{k+1}(x) + x\,P'_{k+1}(x)$. Заменяя $P_{k+1}(x)$ на $b_{k+1}$ и $P'_{k+1}(x)$ на $c_{k+1}$, получаем формулу для $c_k$.

---

## 5. Пошаговые примеры

### 5.1. Степень 1 (линейный многочлен)

Пусть
$$
P(x) = a_0 + a_1 x.
$$

Инициализация: $b_1=a_1,\; c_1=0$. Шаг $k=0$:
$$
b_0 = a_0 + x\,b_1 = a_0 + a_1 x,\qquad
c_0 = b_1 + x\,c_1 = a_1.
$$

**Числовой пример:** $a_0=2,\; a_1=5,\; x=3$  
$b_0=17,\; c_0=5 \Rightarrow P(3)=17,\; P'(3)=5$.

---

### 5.2. Степень 2 (квадратичный многочлен)

$$
P(x) = a_0 + a_1 x + a_2 x^2.
$$

Инициализация: $b_2=a_2,\; c_2=0$.  
Шаг $k=1$: $b_1 = a_1 + x b_2,\; c_1 = b_2$.  
Шаг $k=0$: $b_0 = a_0 + x b_1,\; c_0 = b_1 + x c_1 = a_1 + 2a_2 x$.

**Числовой пример:** $a_0=2,\; a_1=3,\; a_2=5,\; x=2$  
$b_0=28,\; c_0=23 \Rightarrow P(2)=28,\; P'(2)=23$.

---

### 5.3. Пример для $n=3$

$$
P(x)=a_0+a_1x+a_2x^2+a_3x^3,\quad x=2.
$$

Инициализация: $b_3=a_3,\; c_3=0$.  
$k=2$: $b_2=a_2+2a_3,\; c_2=a_3$.  
$k=1$: $b_1=a_1+2b_2,\; c_1=b_2+2a_3$.  
$k=0$: $b_0=a_0+2b_1,\; c_0=b_1+2c_1$.

---

## 6. Псевдокод

```
input: n, a[0..n], x
b = a[n]
c = 0
for k = n-1 downto 0:
    c = c * x + b
    b = b * x + a[k]
return (b, c)   // b = P(x), c = P'(x)
```

Сложность: $O(n)$ по времени и $O(1)$ по памяти (кроме массива коэффициентов).

---

## 7. Численная устойчивость: коротко

- Разные масштабы коэффициентов + большие $|x|$ усиливают округлённые ошибки. Горнер уменьшает, но не отменяет это.  
- Пограничные случаи легко проверяются: при $x=0$ получаем $P(0)=a_0$ и $P'(0)=a_1$; при $n=0$ — $P(x)=a_0$, $P'(x)=0$.

---

## 8. Наборы для быстрой проверки

1) $n=1,\; a=[2,5],\; x=3 \Rightarrow P=17,\; P'=5$.  
2) $n=2,\; a=[2,3,5],\; x=2 \Rightarrow P=28,\; P'=23$.  
3) $n=3,\; a=[2,3,5,7],\; x=2 \Rightarrow P=84,\; P'=107$.  
4) $n=0,\; a=[-4],\; x=100 \Rightarrow P=-4,\; P'=0$.

---

## 9. Реализация на C 

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    int n;
    printf("Enter the degree of the polynomial (n): ");
    scanf("%d", &n);

    double *a = (double*)malloc((n + 1) * sizeof(double));
    if (!a) { printf("Error: not enough memory.\n"); return 1; }

    printf("Enter %d coefficients (from a[0] to a[%d]):\n", n + 1, n);
    for (int i = 0; i <= n; ++i) {
        printf("a[%d] = ", i);
        scanf("%lf", &a[i]);
    }

    double x;
    printf("Enter the value of x: ");
    scanf("%lf", &x);

    // --- Алгоритм Горнера: одновременное вычисление P(x) и P'(x) ---
    double b = a[n];   // значение многочлена на текущем шаге
    double c = 0.0;    // значение производной на текущем шаге
    for (int k = n - 1; k >= 0; --k) {
        c = c * x + b;      // новое значение производной
        b = b * x + a[k];   // новое значение многочлена
    }

    printf("\n--- Results ---\n");
    printf("P(x)  = %.6f\n", b);
    printf("P'(x) = %.6f\n", c);

    free(a);
    return 0;
}
```

---

## 10. Частые ошибки

- Перепутан порядок коэффициентов (нужно $a_0, a_1, \dots, a_n$).
- Неверная инициализация ($b=a_n$, $c=0$).
- Неправильный диапазон цикла ($k$ идёт от $n-1$ до $0$).

---

## 11. Короткая шпаргалка

- Сворачиваем справа налево: каждый шаг — $x \cdot (\text{текущее}) + a_k$.  
- Для производной применяем $(x f)' = f + x f'$.  
- Итоговые формулы: $b_k = a_k + x b_{k+1}$, $c_k = b_{k+1} + x c_{k+1}$; ответ — $b_0$ и $c_0$.
