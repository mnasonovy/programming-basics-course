# Группировка элементов с чётными и нечётными индексами

## 1. Условие задачи

Дан массив (список) чисел.  
Нужно выполнить следующее преобразование:

- Сначала должны идти **все элементы, у которых индекс чётный**  
  (0, 2, 4, 6, …),  
  при этом порядок этих элементов должен **сохраниться**.

- Затем должны идти **все элементы с нечётными индексами**  
  (1, 3, 5, 7, …),  
  и их порядок также должен **сохраниться**.

Пример:  
Исходный массив: `[0, 1, 2, 3, 4, 5, 6]`  
Результат: `[0, 2, 4, 6, 1, 3, 5]`

## 2. Теоретическая справка

### Индекс элемента массива
В языках программирования элементы массива нумеруются с **нуля**.

Пример:
```c
int arr[] = {10, 20, 30, 40};
```

Индексы:
- `10` → 0
- `20` → 1
- `30` → 2
- `40` → 3

### Чётные и нечётные индексы
- Чётные индексы: 0, 2, 4, 6, …
- Нечётные индексы: 1, 3, 5, 7, …

### Проход по массиву
Цикл `for`:

```c
for (int i = 0; i < n; i++) {
    printf("%d", arr[i]);
}
```

Для нашей задачи важно проверять индекс:

```c
if (i % 2 == 0) {
    // чётный индекс
}
```

## 3. Алгоритм программы

1. Создать исходный массив.
2. Создать два дополнительных массива:
    - `even[]` — элементы с чётными индексами
    - `odd[]` — элементы с нечётными индексами
3. Пройтись циклом по исходному массиву.
4. Если индекс чётный → добавить в `even`.
5. Если нечётный → добавить в `odd`.
6. Создать итоговый массив `result[]`.
7. Скопировать сначала `even`, потом `odd`.
8. Вывести результат.

## 4. Код программы (C)

```c
#include <stdio.h>

int main() {
    int arr[] = {0, 1, 2, 3, 4, 5, 6};
    int n = sizeof(arr) / sizeof(arr[0]);

    int even[n], odd[n];
    int even_count = 0, odd_count = 0;

    // Разделение элементов на чётные и нечётные индексы
    for (int i = 0; i < n; i++) {
        if (i % 2 == 0) {          // чётный индекс
            even[even_count] = arr[i];
            even_count++;
        } else {                   // нечётный индекс
            odd[odd_count] = arr[i];
            odd_count++;
        }
    }

    // Создание результирующего массива
    int result[n];
    int idx = 0;

    // Добавляем чётные элементы
    for (int i = 0; i < even_count; i++) {
        result[idx] = even[i];
        idx++;
    }

    // Добавляем нечётные элементы
    for (int i = 0; i < odd_count; i++) {
        result[idx] = odd[i];
        idx++;
    }

    // Вывод результата
    printf("Исходный массив: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }

    printf("\nПреобразованный массив: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", result[i]);
    }

    return 0;
}
```

## 5. Пример работы программы

**Ввод:**
```
[0, 1, 2, 3, 4, 5, 6]
```

**Шаги:**
- Чётные индексы → `[0, 2, 4, 6]`
- Нечётные индексы → `[1, 3, 5]`

**Вывод:**
```
Исходный массив: 0 1 2 3 4 5 6
Преобразованный массив: 0 2 4 6 1 3 5
```
