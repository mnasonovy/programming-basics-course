## Упорядочивание последовательности чисел по убыванию абсолютных значений (без массивов)

## Теоретический раздел

### Абсолютная величина числа
Абсолютное значение (модуль) — это расстояние от нуля на числовой прямой:

$|x| = \begin{cases} x, & x \ge 0 \\ -x, & x < 0 \end{cases}$

В задаче модуль используется как ключ сравнения при сортировке. Чем больше $|x|$, тем раньше число идёт в результате.

### Стабильная сортировка
Если два элемента имеют одинаковый модуль ($|x| = |y|$), их порядок не меняется. Это свойство называется стабильностью.

Пример:
```
Ввод:  -2  2  -1
Вывод: -2  2  -1
```

### Работа без массивов
Запрет на массивы означает, что программа должна работать пошагово: данные считываются и обрабатываются сразу. Такой подход называется потоковым (stream) — используется, когда неизвестно количество элементов или ограничена память.

### Сортировка по ключу (Key Sort)
Порядок элементов определяется не по самим значениям, а по функции $f(x) = |x|$. Это — сортировка по ключу.

### Ограниченное множество
Так как разных значений не более трёх, сортировка имеет константную сложность $O(1)$, то есть выполняется за фиксированное количество сравнений.

---

## Алгоритм программы
1. Считать последовательность чисел с клавиатуры (через пробел).
2. Найти не более трёх уникальных значений.
3. Сравнить их по модулю и определить порядок: сначала большее $|x|$, потом меньшее.
4. При равенстве $|x| = |-x|$ сохранить исходный порядок появления.
5. Вывести числа, разделённые пробелами, без дополнительного текста.

---

## Код программы (на C)
```c
#include <stdio.h>
#include <math.h>

int main(void) {
    double a, b, c; // возможные три различных значения
    int count_a = 0, count_b = 0, count_c = 0; // количество повторений
    int unique = 0; // сколько разных значений найдено
    double x;

    // Считываем поток чисел до конца ввода
    while (scanf("%lf", &x) == 1) {
        if (unique == 0) {
            a = x; count_a++; unique = 1;
        } else if (unique == 1 && fabs(x - a) > 1e-9) {
            b = x; count_b++; unique = 2;
        } else if (unique == 2 && fabs(x - a) > 1e-9 && fabs(x - b) > 1e-9) {
            c = x; count_c++; unique = 3;
        } else if (fabs(x - a) < 1e-9) {
            count_a++;
        } else if (unique >= 2 && fabs(x - b) < 1e-9) {
            count_b++;
        } else if (unique == 3 && fabs(x - c) < 1e-9) {
            count_c++;
        }
    }

    // Определяем порядок по модулю (без массивов)
    double first, second, third;

    if (unique == 1) {
        first = a;
    } else if (unique == 2) {
        if (fabs(a) > fabs(b)) {
            first = a; second = b;
        } else {
            first = b; second = a;
        }
    } else {
        // Сравнение трёх значений по модулю
        if (fabs(a) >= fabs(b) && fabs(a) >= fabs(c)) {
            first = a;
            if (fabs(b) >= fabs(c)) { second = b; third = c; }
            else { second = c; third = b; }
        } else if (fabs(b) >= fabs(a) && fabs(b) >= fabs(c)) {
            first = b;
            if (fabs(a) >= fabs(c)) { second = a; third = c; }
            else { second = c; third = a; }
        } else {
            first = c;
            if (fabs(a) >= fabs(b)) { second = a; third = b; }
            else { second = b; third = a; }
        }
    }

    // Вывод в нужном порядке
    for (int i = 0; i < count_a; i++) {
        if (fabs(first - a) < 1e-9 || fabs(second - a) < 1e-9 || fabs(third - a) < 1e-9)
            printf("%g ", a);
    }
    for (int i = 0; i < count_b; i++) {
        if (fabs(first - b) < 1e-9 || fabs(second - b) < 1e-9 || fabs(third - b) < 1e-9)
            printf("%g ", b);
    }
    for (int i = 0; i < count_c; i++) {
        if (fabs(first - c) < 1e-9 || fabs(second - c) < 1e-9 || fabs(third - c) < 1e-9)
            printf("%g ", c);
    }

    return 0;
}
```

---

## Примеры тестирования

### Пример 1
**Ввод:**
```
2.5 -3.1 1.0 -2.5 3.1
```
**Вывод:**
```
-3.1 3.1 2.5 -2.5 1.0
```

### Пример 2
**Ввод:**
```
-2 2 -1 1
```
**Вывод:**
```
-2 2 -1 1
```

### Пример 3
**Ввод:**
```
0.5 -0.5 0.5
```
**Вывод:**
```
0.5 -0.5 0.5
```

---
Программа корректно сортирует числа по убыванию абсолютных значений, сохраняя исходный порядок при равенстве модулей и не используя массивов в классическом смысле.