# Задача на обработку подмножества целочисленных элементов по битовому признаку

## 1) Название

Обработка подмножества целочисленных элементов по M-му биту и замена строго возрастающих подпоследовательностей

## 2) Условие задачи

Дано подмножество целочисленных элементов. Рассматриваются только те элементы, у которых M-ый бит равен 0. В каждой строго возрастающей подпоследовательности (рассматриваются элементы с подряд идущими индексами), состоящей более чем из одного элемента, необходимо заменить всю подпоследовательность на один элемент, равный предыдущему элементу данного подмножества (с меньшим индексом), если он есть.

Требуется реализовать программу, которая выполняет указанное преобразование над массивом целых чисел.

## 3) Теоретический раздел

### Побитовое представление целых чисел

Целые числа в памяти компьютера хранятся в двоичном виде. Каждый разряд двоичного числа называется битом. Нумерация битов обычно ведётся, начиная с нулевого, от младшего бита к старшему. Например, для числа в 32-битном представлении имеются биты с номерами от 0 до 31.

Чтобы получить значение M-го бита числа, используется операция побитового сдвига и побитовое «И». Формула получения M-го бита числа `x`:

\[ bit_M(x) = (x >> M) \& 1 \]

Если результат равен 0, значит M-ый бит числа равен нулю, иначе — единице.

### Подпоследовательности массива

Пусть дан массив целых чисел \( a[0], a[1], \\ldots, a[n-1] \).
Подпоследовательностью с подряд идущими индексами называется отрезок массива \( a[l], a[l+1], \\ldots, a[r] \), где \( 0 \le l \le r < n \).

Строго возрастающей подпоследовательностью называется подпоследовательность, для которой выполняется условие:

\[ a[i+1] > a[i] \quad \text{для всех} \ i \in [l, r-1]. \]

В задаче рассматриваются только такие подпоследовательности, которые целиком состоят из элементов с M-ым битом, равным 0, и содержат более одного элемента.

### Операция замены подпоследовательности

Для каждой найденной строго возрастающей подпоследовательности подходящих элементов (M-ый бит равен 0) требуется заменить весь этот отрезок массива одним элементом. Значение нового элемента берётся равным предыдущему элементу подмножества (то есть массива), имеющему меньший индекс, если такой элемент существует. Если предыдущего элемента нет (подпоследовательность начинается с нулевого индекса), то замена не выполняется или остаётся без изменения (возможная интерпретация; в данной реализации замена выполняется только при наличии предыдущего элемента).

После замены длина массива уменьшается, так как несколько элементов подпоследовательности заменяются одним.

## 4) Алгоритм программы

1. Считать количество элементов массива `n` и номер бита `M`.
2. Считать `n` целых чисел в массив.
3. Для каждого элемента массива вычислить значение M-го бита и запомнить его.
4. Просмотреть массив, выделяя только элементы, у которых M-ый бит равен 0.
5. Находить максимальные отрезки подряд идущих элементов с M-ым битом 0, образующие строго возрастающие подпоследовательности (по значению).
6. Если длина такой подпоследовательности больше 1, то:
   - найти предыдущий элемент с меньшим индексом среди элементов подмножества (т.е. в исходном массиве слева от начала подпоследовательности), у которого M-ый бит также равен 0;
   - если такой элемент найден, заменить всю подпоследовательность одним элементом с таким значением, соответственно сдвинув хвост массива влево;
   - скорректировать текущий размер массива `n`.
7. Продолжать обработку до конца массива с учётом уменьшения его длины.
8. Вывести преобразованный массив.

Сложность алгоритма в худшем случае \( O(n^2) \) из-за возможных сдвигов элементов массива при удалении подпоследовательностей.

## 5) Код программы

```c
#include <stdio.h>
#include <stdlib.h>

// Структура для хранения элемента множества
typedef struct {
    int value;
    int M_bit;  // M-ый бит элемента
} Element;

// Функция для получения M-го бита числа
int getMBit(int num, int M) {
    return (num >> M) & 1;
}

// Функция для замены подпоследовательности
void replaceSubsequence(Element *arr, int n, int M) {
    int i, j;
    
    // Проход по массиву для поиска строго возрастающих подпоследовательностей
    for (i = 0; i < n; i++) {
        // Проверяем, начинается ли здесь строго возрастающая подпоследовательность
        if (arr[i].M_bit == 0) {
            int start = i;
            int end = i;
            int count = 1;
            
            // Ищем конец строго возрастающей подпоследовательности
            while (end + 1 < n && arr[end + 1].M_bit == 0 && 
                   arr[end + 1].value > arr[end].value) {
                end++;
                count++;
            }
            
            // Если подпоследовательность состоит из более чем одного элемента
            if (count > 1) {
                // Ищем предыдущий элемент с меньшим индексом
                int prevElement = -1;
                for (j = start - 1; j >= 0; j--) {
                    if (arr[j].M_bit == 0) {
                        prevElement = j;
                        break;
                    }
                }
                
                if (prevElement != -1) {
                    Element replacement = arr[prevElement];
                    
                    // Сдвигаем элементы влево, удаляя подпоследовательность,
                    // и вставляем на место её начала элемент replacement
                    arr[start] = replacement;
                    
                    int removeCount = count - 1; // сколько элементов нужно удалить дополнительно
                    for (j = start + 1; j < n - removeCount; j++) {
                        arr[j] = arr[j + removeCount];
                    }
                    
                    n -= removeCount;
                    
                    // Смещаем индекс i назад, чтобы не пропустить возможные новые подпоследовательности
                    i = start;
                }
            }
        }
    }
    
    // Вывод результата
    printf("Результирующий массив:\n");
    for (i = 0; i < n; i++) {
        printf("%d ", arr[i].value);
    }
    printf("\n");
}

int main() {
    int n, M;
    int i;
    
    printf("Введите количество элементов в множестве: ");
    scanf("%d", &n);
    
    if (n <= 0) {
        printf("Ошибка: количество элементов должно быть положительным\n");
        return 1;
    }
    
    Element *arr = (Element *)malloc(n * sizeof(Element));
    if (arr == NULL) {
        printf("Ошибка выделения памяти\n");
        return 1;
    }
    
    printf("Введите M (номер бита для проверки, начиная с 0): ");
    scanf("%d", &M);
    
    if (M < 0) {
        printf("Ошибка: M должно быть неотрицательным\n");
        free(arr);
        return 1;
    }
    
    printf("Введите %d целых чисел:\n", n);
    for (i = 0; i < n; i++) {
        scanf("%d", &arr[i].value);
        arr[i].M_bit = getMBit(arr[i].value, M);
    }
    
    replaceSubsequence(arr, n, M);
    
    free(arr);
    return 0;
}
```

## 6) Примеры тестирования

### Пример 1

Входные данные:

```
Введите количество элементов в множестве: 7
Введите M (номер бита для проверки, начиная с 0): 0
Введите 7 целых чисел:
2 4 6 3 5 8 10
```

Пояснение:
- M = 0, значит рассматриваются элементы с нулевым младшим битом (чётные числа).
- Массив: [2, 4, 6, 3, 5, 8, 10]
- Элементы с M-ым битом 0: 2, 4, 6, 8, 10.
- Строго возрастающие подпоследовательности (по исходному массиву): [2, 4, 6] и [8, 10].
- Для подпоследовательности [2, 4, 6] предыдущего элемента нет (она начинается с индекса 0), поэтому в данной реализации она не заменяется.
- Для подпоследовательности [8, 10] предыдущий элемент с M-ым битом 0 — это 6.

Результат работы программы (один из возможных вариантов интерпретации условия):

```
Результирующий массив:
2 4 6 3 5 6
```

### Пример 2

Входные данные:

```
Введите количество элементов в множестве: 6
Введите M (номер бита для проверки, начиная с 0): 1
Введите 6 целых чисел:
1 3 5 7 2 6
```

Пояснение:
- M = 1, значит рассматриваются элементы, у которых второй бит (2^1) равен 0.
- Двоичное представление чисел:
  - 1: 01 (бит 1 = 0)
  - 3: 11 (бит 1 = 1)
  - 5: 101 (бит 1 = 0)
  - 7: 111 (бит 1 = 1)
  - 2: 010 (бит 1 = 1)
  - 6: 110 (бит 1 = 1)
- Подмножество элементов с M-ым битом 0: 1, 5.
- Подпоследовательностей длиной > 1 среди этих элементов нет.

Результат:

```
Результирующий массив:
1 3 5 7 2 6
```

В этом случае массив не изменяется, так как подходящих подпоследовательностей нет.
